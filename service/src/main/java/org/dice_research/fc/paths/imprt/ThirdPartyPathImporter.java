package org.dice_research.fc.paths.imprt;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.math3.util.Pair;
import org.apache.jena.rdf.model.Property;
import org.apache.jena.rdf.model.ResourceFactory;
import org.dice_research.fc.data.QRestrictedPath;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class enables the import of paths generated by external libraries into COPAAL's native
 * {@link QRestrictedPath} either by file or through serialization.
 * 
 * @author Alexandra Silva
 *
 */
public class ThirdPartyPathImporter {

  private static final String PREDICATE = "Predicate:";

  private static final String PROPERTY_PATH_REGEX = "(\\^?)<(.+?)>";

  private static final Logger LOGGER = LoggerFactory.getLogger(ThirdPartyPathImporter.class);

  /**
   * Imports pre-processed paths from file, the paths are expected to be in the below format:
   * 
   * <pre>
   * {@code
   * Predicate: <http://example.org#randomProperty> 
   * 0.6,<http://example.org#randomProperty2>/^<http://example.org#randomProperty3>
   * }
   * </pre>
   * 
   * If the scores are already calculated, these can be provided as the first element (otherwise
   * it's expected to be empty), followed by the corresponding property path. If the paths are meant
   * to be traversed in an inverse manner, this can be denoted by the prefix {@literal ^}.
   * 
   * @param fileName file name of the paths we wish to import
   * @return a map with each predicate's paths
   */

  public static Map<Property, Collection<QRestrictedPath>> importPathsFromFile(String fileName) {
    Map<Property, Collection<QRestrictedPath>> map =
        new HashMap<Property, Collection<QRestrictedPath>>();
    try (BufferedReader br = new BufferedReader(new FileReader(fileName));) {
      String line;
      Property curPredicate = null;
      while ((line = br.readLine()) != null) {

        // skip line if empty
        if (line.isEmpty()) {
          continue;
        }

        // parse new property
        if (line.contains(PREDICATE)) {
          curPredicate = ResourceFactory.createProperty(line.replace(PREDICATE, "").trim());
          continue;
        }

        if (curPredicate == null) {
          LOGGER.error("There was a problem importing the paths.");
          return null;
        }

        // separate score from path
        String[] lineItems = line.split(",");

        // convert path string to path object
        List<Pair<Property, Boolean>> pathElements = convertPathToPairs(lineItems[1]);
        QRestrictedPath path = new QRestrictedPath(pathElements);
        String scoreStr = lineItems[0];
        if (!scoreStr.isEmpty()) {
          path.setScore(Double.parseDouble(scoreStr));
        }

        // commit result to map
        map.putIfAbsent(curPredicate, new ArrayList<QRestrictedPath>());
        map.get(curPredicate).add(path);

      }
    } catch (IOException e) {
      e.printStackTrace();
    }
    if (map.isEmpty()) {
      LOGGER.error("The imported paths are empty. Are you sure the file is in the correct format?");
    }
    return map;
  }

  /**
   * Converts the property path string into the corresponding pairs through regex, extracting the
   * uri and its inverse operator {@literal ^}
   * 
   * @param propertyPath the property path as a string
   * @return {@link List} the properties belonging to a path
   */
  public static List<Pair<Property, Boolean>> convertPathToPairs(String propertyPath) {
    List<Pair<Property, Boolean>> pathElements = new ArrayList<Pair<Property, Boolean>>();

    Pattern pattern = Pattern.compile(PROPERTY_PATH_REGEX);
    Matcher matcher = pattern.matcher(propertyPath);
    while (matcher.find()) {
      String operator = matcher.group(1);
      String uri = matcher.group(2);

      boolean isInverse = operator.contains("^") ? false : true;

      Property property = ResourceFactory.createProperty(uri);
      pathElements.add(new Pair<Property, Boolean>(property, isInverse));
    }
    return pathElements;
  }

  /**
   * Imports the serialized pre-processed paths. This relies on the compatibility with the
   * serializable {@link QRestrictedPath}.
   * 
   * @param fileName path to the serialized paths
   * @return {@link HashMap} with the properties' pre-processed paths
   */
  public static HashMap<Property, List<QRestrictedPath>> importPathsFromObject(String fileName) {

    HashMap<Property, List<QRestrictedPath>> map = new HashMap<Property, List<QRestrictedPath>>();

    try (FileInputStream fileOutStream = new FileInputStream(fileName);
        ObjectInputStream objOutStream = new ObjectInputStream(fileOutStream);) {

      map = (HashMap<Property, List<QRestrictedPath>>) objOutStream.readObject();

    } catch (IOException ioe) {
      ioe.printStackTrace();
    } catch (ClassNotFoundException e) {
      e.printStackTrace();
    }
    return map;
  }

}
