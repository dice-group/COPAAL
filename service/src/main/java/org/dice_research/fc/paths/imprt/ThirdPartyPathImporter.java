package org.dice_research.fc.paths.imprt;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.math3.util.Pair;
import org.apache.jena.rdf.model.Property;
import org.apache.jena.rdf.model.ResourceFactory;
import org.dice_research.fc.data.QRestrictedPath;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class enables the import of paths generated by external libraries into COPAAL's native
 * {@link QRestrictedPath} by file.
 * 
 * @author Alexandra Silva
 *
 */
public class ThirdPartyPathImporter {

  private static final String PREDICATE_REGEX = "Predicate: <(.+?)>";

  private static final String PROPERTY_PATH_REGEX = "(\\^?)<(.+?)>";
  
  private static final String DELIMITER = "^(-?[0-9]+\\.[0-9]+)?\\,(\\^?<.+>)?";

  private static final Logger LOGGER = LoggerFactory.getLogger(ThirdPartyPathImporter.class);

  /**
   * Imports pre-processed paths from file, the paths are expected to be in the below format:
   * 
   * <pre>
   * {@code
   * Predicate: <http://example.org#randomProperty> 
   * 0.6,<http://example.org#randomProperty2>/^<http://example.org#randomProperty3>
   * }
   * </pre>
   * 
   * If the scores are already calculated, these can be provided as the first element (otherwise
   * it's expected to be empty), followed by the corresponding property path. If the paths are meant
   * to be traversed in an inverse manner, this can be denoted by the prefix {@literal ^}.
   * 
   * @param fileName file name of the paths we wish to import
   * @return a map with each predicate's paths
   */

  public static Map<Property, Collection<QRestrictedPath>> importPathsFromFile(String fileName) {
    Map<Property, Collection<QRestrictedPath>> map =
        new HashMap<Property, Collection<QRestrictedPath>>();
    try (BufferedReader br = new BufferedReader(new FileReader(fileName));) {
      String line;
      Property curPredicate = null;
      while ((line = br.readLine()) != null) {

        // skip line if empty
        if (line.isEmpty()) {
          continue;
        }

        // parse new property
        Property cur = getPredicate(line);
        if (cur != null) {
          curPredicate = cur;
          continue;
        }

        if (curPredicate == null) {
          LOGGER.error("There was a problem importing the paths.");
          return null;
        }

        // separate score from path
        String score = null;
        String propertyPath = null;
        Pattern pattern = Pattern.compile(DELIMITER);
        Matcher matcher = pattern.matcher(line);
        if (matcher.find()) {
          score = matcher.group(1);
          propertyPath = matcher.group(2);
        }

        // if there are no paths
        if (propertyPath == null || propertyPath.isEmpty()) {
          map.putIfAbsent(curPredicate, new ArrayList<QRestrictedPath>());
          continue;
        }

        // convert path string to path object
        List<Pair<Property, Boolean>> pathElements = convertPathToPairs(propertyPath);
        QRestrictedPath path = new QRestrictedPath(pathElements);
        if (score != null) {
          path.setScore(Double.parseDouble(score));
        }
        
        // commit result to map
        map.putIfAbsent(curPredicate, new ArrayList<QRestrictedPath>());
        map.get(curPredicate).add(path);

      }
    } catch (IOException e) {
      e.printStackTrace();
    }
    if (map.isEmpty()) {
      LOGGER.error("The imported paths are empty. Are you sure the file is in the correct format?");
    }
    return map;
  }

  /**
   * Converts the property path string into the corresponding pairs through regex, extracting the
   * uri and its inverse operator {@literal ^}
   * 
   * @param propertyPath the property path as a string
   * @return {@link List} the properties belonging to a path
   */
  public static List<Pair<Property, Boolean>> convertPathToPairs(String propertyPath) {
    List<Pair<Property, Boolean>> pathElements = new ArrayList<Pair<Property, Boolean>>();

    Pattern pattern = Pattern.compile(PROPERTY_PATH_REGEX);
    Matcher matcher = pattern.matcher(propertyPath);
    while (matcher.find()) {
      String operator = matcher.group(1);
      String uri = matcher.group(2);

      // can we deal with the property as is or is it inverse
      boolean isAsIs = operator.contains("^") ? false : true;

      Property property = ResourceFactory.createProperty(uri);
      pathElements.add(new Pair<Property, Boolean>(property, isAsIs));
    }
    return pathElements;
  }

  /**
   * Extracts the property from the input string if existing
   * 
   * @param line the line where the predicate is supposed to be
   * @return the {@link Property} object
   */
  public static Property getPredicate(String line) {
    Pattern pattern = Pattern.compile(PREDICATE_REGEX);
    Matcher matcher = pattern.matcher(line);
    Property predicate = null;
    if (matcher.find()) {
      predicate = ResourceFactory.createProperty(matcher.group(1));
    }
    return predicate;
  }

}
